""" Incoming firmware queries, specifically from devices, are handled
    by this module.

    The functions here mirror the requests generated by the firmware
    upgrade requests and functions made in the Paikea device firmware.

    These are to be triggered by API calls to the backend.

    Calls to the API generate a dict which is passed to certain functions.

    This dict needs a 'cmd' key which matches in the upgrade_request_handlers
    used by hande_upgrade_req to route the request to the appropriate function.

    The general flow is to check if there exists an upgrade, init one if there
    isn't, and request the status until it's ready.  Once ready, the metadata
    for the upgrade is retrieved, files are retrieved, and if the upgrade
    is successful, to request to complete the upgrade.
"""
import hashlib
import os
from os.path import join, getsize
from sqlalchemy.orm.exc import NoResultFound
from paikea.extensions import db
from paikea import tasks
from paikea import models as md
from paikea.firmware_utils import UpgradeStatus


def file_hash(path):
    ''' Calculate the sha1 hash of a file used on both the server and device
        side to communicate file integrity

        :param str path: path to file to be hashed
    '''
    hasher = hashlib.sha1()
    with open(path, 'rb') as f:
        buf = f.read()
    hasher.update(buf)
    return hasher.hexdigest()


def upgrade_metadata(path):
    """ Create the metadata associated with a firmware upgrade, consisting
    of the list of directories, files, and hashs to be sent to a device

    :param str path: path to firmware upgrade directory
    :return: dictionary of the files, hashes, directories, and size of upgrade
    :rtype: dict
    """
    fw_dirs = set()
    total_sz = 0
    fw_files = {}
    os.chdir(path)
    fw_path = os.walk(".")

    for dir, subdirs, files in fw_path:
        if ".git" in dir:
            continue

        fw_dirs.add(dir)

        for fi in files:
            sz = getsize(join(dir, fi))
            total_sz += sz
            fw_files[join(dir, fi)] = [
                sz,
                file_hash(join(dir, fi))]

    return {'size': total_sz,
            'dirs': list(fw_dirs),
            'files': fw_files}


def new_upgrade(data):
    """ Create a new DeviceFirmwareUpgrade.

    :param dict data: request data identifying device
    """
    upgrade = md.DeviceFirmwareUpgrade(
        device_type=data['device_type'],
        device_id=data['device_id'])

    db.session.add(upgrade)
    try:
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        raise e


def init_upgrade(data):
    """ Initialize the filesystem for a device firmware upgrade

    :param dict data: device request data
    """
    dev_type = data['device_type']
    dev_id = data['device_id']

    # TODO: check for in-progress upgrade
    upgrade = md.DeviceFirmwareUpgrade(
        device_type=dev_type,
        device_id=dev_id,
        status=UpgradeStatus["INIT"])
    db.session.add(upgrade)
    try:
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        raise e

    tasks.prepare_update_directory.delay(upgrade.id)

    return {'job_id': upgrade.id,
            'status': upgrade.status}


def check_upgrade(data):
    """ Check the status of an existing upgrade.  As upgrades require
    filesystem operations, an initialization of an upgrade is not
    instantaneous.

    When the upgrade is ready, the file system operations have completed, and
    the device can request the metadata associated with the upgrade.

    :param dict data: upgrade request data including device identification
    :return: Dict with id of upgrade job and job status
    :rtype: dict
    """
    dev_type = data['device_type']
    dev_id = data['device_id']
    job_id = data.get('job_id')

    if job_id:
        try:
            upgrade = db.session.query(md.DeviceFirmwareUpgrade).filter_by(
                id=job_id).one()
        except NoResultFound:
            return {'job_id': job_id,
                    'status': UpgradeStatus["NONE"]}

        return {'job_id': upgrade.id,
                'status': upgrade.status}

    upgrades = db.session.query(md.DeviceFirmwareUpgrade).filter_by(
        device_type=dev_type,
        device_id=dev_id).filter(
            md.DeviceFirmwareUpgrade.status.notin_([
                UpgradeStatus["SUCCESS"],
                UpgradeStatus["FAIL"],
                UpgradeStatus["NOT_AVAIL"],
                UpgradeStatus["NONE"],
            ])).all()

    if len(upgrades) == 0:
        return {'job_id': 0,
                'status': UpgradeStatus["NONE"]}

    elif len(upgrades) > 1:
        # need to clean up older requests that should be finished
        return {'job_id': 0,
                'status': UpgradeStatus["SERVER_ERROR"]}

    else:
        return {'job_id': upgrades[0].id,
                'status': upgrades[0].status}


def get_metadata(data):
    """ The metatdata for the upgrade is the size of the files to be trasfered,
    the list of directories and files, and the hashes for the files.

    :param dict data: request data including device idenfication
    :return: dict with upgrade job id and job status
    :rtype: dict
    """
    job_id = data['job_id']
    upgrade = db.session.query(md.DeviceFirmwareUpgrade).filter_by(id=job_id).one()
    if upgrade.status == UpgradeStatus["READY"]:
        return upgrade_metadata(upgrade.full_path())
    else:
        return {'job_id': upgrade.id,
                'status': upgrade.status}


def send_file(data):
    """ When a device requests a file, this function retrieves the full path
    to the file based on the stored DeviceFirmwareUpgrade.  This limits access
    to the filesystem.  The file is actually served by the associated route.

    :param dict data: request data with job id and file request
    :return: dict with full path to file to serve
    :rtype: dict
    """
    job_id = data['job_id']
    file_to_send = data['file_path']
    upgrade = db.session.query(md.DeviceFirmwareUpgrade).filter_by(id=job_id).one()

    if upgrade.status != UpgradeStatus["DEVICE_START"]:
        upgrade.status = UpgradeStatus["DEVICE_START"]
        db.session.add(upgrade)
        try:
            db.session.commit()
        except Exception:
            db.session.rollback()

    srv_file_path = upgrade.file_path_suffix + "/" + file_to_send
    print(srv_file_path)
    return {'path': srv_file_path}


def complete(data):
    """ When a device completes it's firmware upgrade, it notifies the server
    if the upgrade was a success or failure, which notifies that this job is
    finished and the server can clean up the filesystem.

    :param dict data: request data with job id and status from device
    """
    job_id = data['job_id']
    status = data['status']
    upgrade = db.session.query(md.DeviceFirmwareUpgrade).filter_by(id=job_id).one()
    if status:
        upgrade.status = UpgradeStatus["SUCCESS"]
    else:
        upgrade.status = UpgradeStatus["FAIL"]
    db.session.add(upgrade)
    try:
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        raise e
    tasks.clear_upgrade_directory.delay(job_id)


upgrade_request_handlers = {
    'check': check_upgrade,
    'init': init_upgrade,
    'status': check_upgrade,
    'metadata': get_metadata,
    'get_file': send_file,
    'complete': complete
}


def handle_upgrade_req(data):
    """ The firmware upgrade view calls this function on the request data to
    route the request data the appropriate function."""
    cmd = data['cmd']
    return upgrade_request_handlers[cmd](data)
